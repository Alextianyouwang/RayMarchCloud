
#pragma kernel CS_DrawSmoke
RWTexture2D<float4> _CloudColRT,_CloudMaskRT,_CloudDepthRT,_CloudAlphaRT;
Texture2D<float> _DepthTextureRT;
SamplerState sampler_DepthTextureRT;

float _ScreenWidth,_ScreenHeight;
float4x4 _CamInvProjection, _CamToWorld , _Unity_VP, _Unity_V;
float3 _CamPosWS;
float _BlendFactor;

float2 _CameraNearFar;

float3 _LightDirection;



struct Sphere
{
    float3 center;
    float radius;
};
StructuredBuffer<Sphere> _SphereBuffer;
int _SphereCount;


static const float maxDist = 30;
static const float epsilon = 0.001;

struct Ray
{
    float3 origin;
    float3 direction;
};

Ray CreateRay(float3 _origin, float3 _direction)
{
    Ray ray;
    ray.origin = _origin;
    ray.direction = _direction;
    return ray;
}
Ray ComputeCameraRay (float2 uv)
{
    
    float3 direction = mul (_CamInvProjection,float4 (uv,0,1)).xyz;
    direction = mul (_CamToWorld,float4 (direction,0)).xyz;
    direction = normalize(direction);
    return  CreateRay(_CamPosWS,direction);
}

struct SceneInfo
{
    float3 position;
    float3 normal;
    float rayDepth;
    int marchStep;
    float alpha;
};

SceneInfo CreateSceneInfo(float3 position, float3 normal, float rayDepth, int marchStep, float alpha)
{
    SceneInfo sceneInfo;
    sceneInfo.position = position;
    sceneInfo.normal = normal;
    sceneInfo.rayDepth = rayDepth;
    sceneInfo.marchStep = marchStep;
    sceneInfo.alpha = alpha;
    return sceneInfo;
}

float Blend( float a, float b, float k )
{
    float h = clamp( 0.5+0.5*(b-a)/k, 0.0, 1.0 );
    const float blendDst = lerp( b, a, h ) - k*h*(1.0-h);
    return blendDst;
}

float Spheres (float3 pos)
{
    float globalDist = maxDist;
    
    for (int i = 0; i<_SphereCount; i ++)
    {
        const float localDist = distance(pos,_SphereBuffer[i].center) - _SphereBuffer[i].radius;
        globalDist = Blend(localDist,globalDist,_BlendFactor) ;
    }
    return globalDist;
}
float SDF (float3 pos)
{
    return  Spheres(pos);
}
float3 GetNormal(float3 pos)
{
    float2 e = float2(0,0.001);
    float x = SDF(pos + e.yxx);
    float y = SDF(pos + e.xyx);
    float z = SDF(pos + e.xxy);
    return normalize( float3 (x,y,z) - SDF(pos));
}

SceneInfo RenderSceneInfo(float3 o, float3 d, float geoDepth)
{
    float3 hitPos,throughPos = 0;
    float hitDist,throughDist  = 0;
    float alpha = 0;
    int marchStep = 0;
    const float pf = dot(d, -_Unity_V[2].xyz);
    while ( hitDist < maxDist)
    {
        marchStep ++;
        throughPos = o + d * hitDist;
        const float distToObject =SDF(throughPos);
        if (distToObject <= epsilon)
        {
            hitPos = throughPos;
            const float3 newO = throughPos - GetNormal(throughPos) * epsilon*4;
            for (int i = 0 ; i< 120; i++)
            {
                throughPos = newO + d * throughDist;
                const float distToBound = SDF(throughPos);
                if ((hitDist + throughDist) * pf > geoDepth)
                    break;
                if (distToBound < 0) 
                    alpha += 0.05;
                throughDist += 0.05;
            }   
            return CreateSceneInfo(hitPos, -GetNormal(hitPos),SDF(_CamPosWS)>0? hitDist:-hitDist+0.001,marchStep, alpha);
        }
        hitDist += distToObject;
    }
    return CreateSceneInfo(0,0,0,marchStep,0);
}

float LinearEyeDepth(float depth) 
{
    float near = _CameraNearFar.x;
    float far = _CameraNearFar.y;
    float x, y, z, w;

    x = -1 + far / near;
    y = 1;
    z = x / far;
    w = 1 / far;

   /* x = 1 - far / near;
    y = far / near;
    z = x / far;
    w = y / far;*/

    return 1.0 / (z * depth + w);
}


[numthreads(8,8,1)]
void CS_DrawSmoke(uint3 id : SV_DispatchThreadID)
{
    const float2 uv = float2 (id.x / _ScreenWidth, id.y / _ScreenHeight);
    const float geometryDepthNDC = _DepthTextureRT.SampleLevel(sampler_DepthTextureRT, uv, 0);
    const float geometryDepthVS = LinearEyeDepth(geometryDepthNDC);
    const Ray camRay = ComputeCameraRay(uv * 2 -1);
    const SceneInfo sceneInfo = RenderSceneInfo(camRay.origin,camRay.direction, geometryDepthVS);
    const float4 posCS = mul (_Unity_VP,float4(sceneInfo.position,1));
   
    const float sceneDepthNDC = posCS.z / (posCS.w + 0.0001);
    const float sceneAlpha = sceneInfo.alpha;
    
    float3 diffuse = saturate( dot(sceneInfo.normal,_LightDirection))/2 + 0.5f;
    _CloudColRT[id.xy] = float4 (diffuse, sceneAlpha) *(sceneDepthNDC > geometryDepthNDC);



    /* _CloudColRT[id.xy] = float4 (sceneInfo.position,1);
 _CloudColRT[id.xy] = sceneInfo.marchStep * 0.01;
 _CloudColRT[id.xy] = float4 (-sceneInfo.normal,1);
 _CloudAlphaRT[id.xy] = sceneAlpha;*/
    //_CloudColRT[id.xy] = float4 (camRay.direction,1);
    //_CloudMaskRT[id.xy] = sceneMask;
    //_CloudMaskRT[id.xy] = 1;
    //_CloudDepthRT[id.xy] = sceneDepthNDC;
}
